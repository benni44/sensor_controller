/**
 * @file main.c
 * @author Benedikt Streicher (streicher.b@posteo.de)
 * @brief An example application for the Sensor Controller in the CC1352P1
 *
 * This application demonstrates how to use the Sensor Controller in the
 * CC1352P1. It is based on the Zephyr board specific example
 * cc13x2_cc26x2/system_off and extends it with the Sensor Controller.
 * It first runs through a sequence of busy-waiting, sleeping and standby and
 * then starts the Sensor Controller task. The Sensor Controller task waits for
 * a button press on the button 1. After the button press, the user has five
 * seconds to press button 2 at least five times. If at least presses are
 * detected, the Sensor Controller task will generate an alert event and wake up
 * the main CPU. The main CPU will then print the number of button presses and
 * shut down the system.
 *
 * @version 0.1
 * @date 2024-03-15
 * 
 * @copyright Copyright (c) 2019 Nordic Semiconductor ASA
 * @copyright Copyright (c) 2020 Linaro Ltd.
 * @copyright SPDX-License-Identifier: Apache-2.0
 * 
 */

#include <stdint.h>
#include <stdio.h>
#include <zephyr/kernel.h>
#include <zephyr/init.h>
#include <zephyr/device.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/sys/poweroff.h>

#include <driverlib/ioc.h>

#include "scif/scif.h"

K_THREAD_STACK_DEFINE(task_stack_area, 512);
struct k_thread task_thread_data;

#define BUSY_WAIT_MS	500U
#define IDLE_MS			3U
#define SLEEP_MS		500U

static const struct gpio_dt_spec led0 = GPIO_DT_SPEC_GET(DT_ALIAS(led0), gpios);
static const struct gpio_dt_spec led1 = GPIO_DT_SPEC_GET(DT_ALIAS(led1), gpios);

extern void CC1352R1_LAUNCHXL_shutDownExtFlash(void);

uint8_t count = 0;

#if CONFIG_SERIAL
/**
 * @brief Callback function for the Task control interface ready event
 *
 * This callback function is called whenever the Sensor Controller task control
 * interface completed a non-blocking task control operation.
 * It is not necessary to implement this callback function, but it can be used
 * to provide feedback to the user that the task control interface is ready. It
 * is also possible to use the callback to execute code only after the operation
 * has completed.
 */
void scCtrlReadyCallback(void) {
	printk("SCIF driver callback: Task control interface ready\n");
}
#endif

void taskAlertThreadEntry(void* p1, void* p2, void* p3) {
	/* Output the number of button presses */
	printk("Button press count: %u\n", count);
	for(uint8_t i = 0; i < count; i++) {
		gpio_pin_set_dt(&led1, 1);
		k_sleep(K_MSEC(2));
		gpio_pin_set_dt(&led1, 0);
		k_sleep(K_MSEC(2));
	}

	/* Shut the system down */
	gpio_pin_set_dt(&led0, 0);
	printk("Shutting down\n");
	sys_poweroff();
}

/**
 * @brief Callback function for the ALERT event from the Sensor Controller
 * 
 * This callback function is called from the Sensor Controller task after an
 * alert event is generated by it.
 * It handles the alert event by reading the count of button 2 presses from the
 * Sensor Controller task and then starting a thread that ouputs the count.
 */
void scTaskAlertCallback(void) {
	/* Clear the ALERT interrupt source */
	scifClearAlertIntSource();

	count = (uint8_t) scifTaskData.buttonTask.output.count;

	/* Acknowledge the ALERT event */
	scifAckAlertEvents();

	k_thread_create(&task_thread_data, task_stack_area, 1024,
		taskAlertThreadEntry, NULL, NULL, NULL, 7, 0, K_NO_WAIT);
}

int main(void)
{
	gpio_pin_configure_dt(&led0, GPIO_OUTPUT);
	gpio_pin_configure_dt(&led1, GPIO_OUTPUT);
	printk("Initializing\n");

	/* Initialize the SCIF operating system abstraction layer */
	scifOsalInit();
#if CONFIG_SERIAL
	scifOsalRegisterCtrlReadyCallback(scCtrlReadyCallback);
#endif
	scifOsalRegisterTaskAlertCallback(scTaskAlertCallback);

	/* Initialize the SCIF driver */
	scifInit(&scifDriverSetup);

	/* Shut off external flash to save power */
	gpio_pin_set_dt(&led0, 1);
	printk("Shutting down external flash\n\n");
	CC1352R1_LAUNCHXL_shutDownExtFlash();

	/* Busy-wait for 1s */
	gpio_pin_set_dt(&led1, 1);
	printk("Busy-wait %u s\n", BUSY_WAIT_MS);
	k_busy_wait(BUSY_WAIT_MS * MSEC_PER_SEC);

	/* IDLE for 4ms */
	gpio_pin_set_dt(&led0, 0);
	printk("Sleep %u ms (IDLE)\n", IDLE_MS);
	k_sleep(K_MSEC(IDLE_MS));

	/* STANDBY for 1s */
	gpio_pin_set_dt(&led1, 0);
	printk("Sleep %u s (STANDBY)\n\n", SLEEP_MS);
	k_sleep(K_MSEC(SLEEP_MS));

	/* Start Sensor Controller task and go to sleep */
	gpio_pin_set_dt(&led0, 1);
	printk("Starting Sensor Controller task and going to sleep\n");
	printk("Press button 1 to wake up and then button 2 at least 5 times.\n\n");
	scifStartTasksNbl(1 << SCIF_BUTTON_TASK_TASK_ID);
	k_sleep(K_FOREVER);
	
	CODE_UNREACHABLE;

	return 0;
}
